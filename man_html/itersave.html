<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: The itersave() function to iteratively run-then-write (to...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for itersave"><tr><td>itersave</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>The itersave() function to iteratively run-then-write (to .rds) the output of a user supplied function</h2>

<h3>Description</h3>

<p>The user supplied function, in the argument 'func_user', is expected to return an object that itersave() can further save physically.
So, itersave() will write a physical .rds file to the user specified directory.
The name of the physical file will use the elements' names in the named vector 'vec_arg_func' as the filename. eg if names(vec_arg_func[[i]])='foo', then the physical file is 'foo.rds'
Note: itersave() uses purrr::safely() with if-else to handle errors.
</p>


<h3>Usage</h3>

<pre>
itersave(func_user, vec_arg_func, mainDir, subDir, subSubDir = "/failed/",
  first = 1, last = length(vec_arg_func), parallel = FALSE,
  timeout = Inf, prog_iter = TRUE, ts = TRUE, walk = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>func_user</code></td>
<td>
<p>a user supplied function taking in a simple argument of one-element</p>
</td></tr>
<tr valign="top"><td><code>vec_arg_func</code></td>
<td>
<p>a named vector whose elements' value will be iteratively used as arguments in func_user.
Further, the vector elements' name will be used as the .rds filename.</p>
</td></tr>
<tr valign="top"><td><code>mainDir</code></td>
<td>
<p>parent directory to write output to</p>
</td></tr>
<tr valign="top"><td><code>subDir</code></td>
<td>
<p>sub directory to write good results to</p>
</td></tr>
<tr valign="top"><td><code>subSubDir</code></td>
<td>
<p>sub sub directory to write bad results to</p>
</td></tr>
<tr valign="top"><td><code>first</code></td>
<td>
<p>integer to start iteration. Defaults to 1</p>
</td></tr>
<tr valign="top"><td><code>last</code></td>
<td>
<p>integer to end iteration. Defaults to length(vec_arg_func)</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
<p>logical to use library(doParallel) back end. Defaults to FALSE</p>
</td></tr>
<tr valign="top"><td><code>timeout</code></td>
<td>
<p>a numeric (default Inf) specifying the maximum number of seconds the expression
is allowed to run before being interrupted by the timeout. Passed to <code>withTimeout</code></p>
</td></tr>
<tr valign="top"><td><code>prog_iter</code></td>
<td>
<p>a logical (default TRUE) if the 'i of last' progress should be printed for each iteration.</p>
</td></tr>
<tr valign="top"><td><code>ts</code></td>
<td>
<p>a logical (default TRUE) if the timestamp should be printed for each iteration.</p>
</td></tr>
<tr valign="top"><td><code>walk</code></td>
<td>
<p>logical (default FALSE). If TRUE, then saveRDS() is not ran for successful iterations.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>extra NAMED arguments passed to func_user via do.call(func_user),args=...)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>iterload</code> to easily load files written by itersave
</p>


<h3>Examples</h3>

<pre>

## NOTE: Must name arg_vec_spec
## using arg vector index as suffix
# names(arg_vec_spec) = paste0('arg_foo',seq_along(arg_vec_spec))
## using last 6 digits of arg value as suffix
# names(arg_vec_spec) = paste0('arg_foo',stringr::str_sub(arg_vec_spec,start=-6))
## left pad with 0 via nchar digits of arg length
# names(arg_vec_spec) = paste0('arg_',
#                              str_pad(seq_along(arg_vec_spec),
#                                      width=nchar(length(arg_vec_spec)),
#                                      side="left", pad="0"))

##################
# success
##################
arg_vec_spec = 1:10
names(arg_vec_spec) = paste0('arg_foo',seq_along(arg_vec_spec))
foo_func_spec = function(x){return(log(x))}

mainDir = '~/projects/datzen/tests/proto/temp/'
subDir = '/dump_1_perfect/'
subSubDir = '/failed_perfect/'

itersave(func_user=foo_func_spec,vec_arg_func=arg_vec_spec,
         mainDir,subDir,subSubDir=subSubDir,parallel=FALSE)

# good files
list.files(paste0(mainDir,subDir),full.names = TRUE)
out=datzen::iterload(paste0(mainDir,subDir))
str(out)

# bad files none
list.files(paste0(mainDir,subDir,subSubDir),full.names = TRUE)

##################
# failure from argument bad
##################
arg_vec_spec = letters
names(arg_vec_spec) = paste0('arg_foo',seq_along(arg_vec_spec))
foo_func_spec = function(x){return(log(x))}

subDir = '/dump_1_argbad/'
subSubDir = '/failed_argbad/'

itersave(func_user=foo_func_spec,vec_arg_func=arg_vec_spec,
         mainDir,subDir,subSubDir=subSubDir,parallel=FALSE)

# good files none
list.files(paste0(mainDir,subDir),full.names = TRUE)

# bad files
list.files(paste0(mainDir,subDir,subSubDir),full.names = TRUE)
out=iterload(paste0(mainDir,subDir,subSubDir))
str(out)

##################
# failure due to timeout
##################

# arg is good
arg_vec_spec = 1:10
names(arg_vec_spec) = paste0('arg_foo',seq_along(arg_vec_spec))

foo_func_spec = function(x){
  wait=sample(c(0,2.0),1); # 0 or 2 second
  Sys.sleep(wait);
  return(log(x))}

subDir = '/dump_1_timeout/'
subSubDir = '/failed_timeout/'

# timeout at 1 second
itersave(func_user=foo_func_spec,vec_arg_func=arg_vec_spec,
         mainDir=mainDir,subDir=subDir,subSubDir=subSubDir,parallel=FALSE,
         timeout=1.0)

# good files some
list.files(paste0(mainDir,subDir),full.names = TRUE)
out=datzen::iterload(paste0(mainDir,subDir))
str(out)

# bad files some
list.files(paste0(mainDir,subDir,subSubDir),full.names = TRUE)
out=datzen::iterload(paste0(mainDir,subDir,subSubDir))
str(out)

##################
# re run failed args
# see ?iterload()
##################

list.files(paste0(mainDir,subDir,subSubDir),full.names = TRUE)
out=datzen::iterload(paste0(mainDir,subDir,subSubDir))
str(out)

transpose(out)$ind_fail
transpose(out)$input_bad

# these examples timed out due to
# random sample of wait time exceeding 2.0

foo_func_spec = function(x){
  # wait=sample(c(0,2.0),1); # 0 or 2 second
  # Sys.sleep(wait);
  return(log(x))}

arg_redo = unlist(transpose(out)$input_bad)
names(arg_redo)
arg_vec_spec = arg_redo

subDir = '/dump_1_redo/'
subSubDir = '/failed_redo/'

itersave(func_user=foo_func_spec,vec_arg_func=arg_vec_spec,
         mainDir=mainDir,subDir=subDir,subSubDir=subSubDir,parallel=FALSE,
         timeout=1.0)

# good files all
list.files(paste0(mainDir,subDir),full.names = TRUE)
out=datzen::iterload(paste0(mainDir,subDir))
str(out)
names(arg_redo)

# bad files none
list.files(paste0(mainDir,subDir,subSubDir),full.names = TRUE)
</pre>


</body></html>
